var documenterSearchIndex = {"docs":
[{"location":"#TuringCallbacks","page":"Home","title":"TuringCallbacks","text":"","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"As the package is not yet officially released, the package has to be added from the GitHub repository:\n\njulia> ]\npkg> add TuringCallbacks.jl","category":"section"},{"location":"#Visualizing-sampling-on-the-fly","page":"Home","title":"Visualizing sampling on-the-fly","text":"TensorBoardCallback is a wrapper around Base.CoreLogging.AbstractLogger which can be used to create a callback compatible with Turing.sample.\n\nTo actually visualize the results of the logging, you need to have installed tensorboard in Python. If you do not have tensorboard installed, it should hopefully be sufficient to just run\n\npip3 install tensorboard\n\nThen you can start up the TensorBoard:\n\npython3 -m tensorboard.main --logdir tensorboard_logs/run\n\nNow we're ready to actually write some Julia code.\n\nThe following snippet demonstrates the usage of TensorBoardCallback on a simple model. This will write a set of statistics at each iteration to an event-file compatible with Tensorboard:\n\nusing Turing, TuringCallbacks\n\n@model function demo(x)\n    s ~ InverseGamma(2, 3)\n    m ~ Normal(0, √s)\n    for i in eachindex(x)\n        x[i] ~ Normal(m, √s)\n    end\nend\n\nxs = randn(100) .+ 1;\nmodel = demo(xs);\n\n# Number of MCMC samples/steps\nnum_samples = 10_000\nnum_adapts = 100\n\n# Sampling algorithm to use\nalg = NUTS(num_adapts, 0.65)\n\n# Create the callback\ncallback = TensorBoardCallback(\"tensorboard_logs/run\")\n\n# Sample\nchain = sample(model, alg, num_samples; callback = callback)\n\nWhile this is sampling, you can head right over to localhost:6006 in your web browser and you should be seeing some plots!\n\n(Image: TensorBoard dashboard)\n\nIn particular, note the \"Distributions\" tab in the above picture. Clicking this, you should see something similar to:\n\n(Image: TensorBoard dashboard)\n\nAnd finally, the \"Histogram\" tab shows a slightly more visually pleasing version of the marginal distributions:\n\n(Image: TensorBoard dashboard)\n\nNote that the names of the stats following a naming $variable_name/... where $variable_name refers to name of the variable in the model.","category":"section"},{"location":"#Choosing-what-and-how-you-log","page":"Home","title":"Choosing what and how you log","text":"","category":"section"},{"location":"#Statistics","page":"Home","title":"Statistics","text":"In the above example we didn't provide any statistics explicit and so it used the default statistics, e.g. Mean and Variance. But using other statistics is easy! Here's a much more interesting example:\n\n# Create the stats (estimators are sub-types of `OnlineStats.OnlineStat`)\nstats = Skip(\n    num_adapts, # Consider adaptation steps\n    Series(\n        # Estimators using the entire chain\n        Series(Mean(), Variance(), AutoCov(10), KHist(100)),\n        # Estimators using the entire chain but only every 10-th sample\n        Thin(10, Series(Mean(), Variance(), AutoCov(10), KHist(100))),\n        # Estimators using only the last 1000 samples\n        WindowStat(1000, Series(Mean(), Variance(), AutoCov(10), KHist(100)))\n    )\n)\n# Create the callback\ncallback = TensorBoardCallback(\"tensorboard_logs/run\", stats)\n\n# Sample\nchain = sample(model, alg, num_samples; callback = callback)\n\nTada! Now you should be seeing waaaay more interesting statistics in your TensorBoard dashboard. See the OnlineStats.jl documentation for more on the different statistics, with the exception of Thin, Skip and WindowStat which are implemented in this package.\n\nNote that these statistic estimators are stateful, and therefore the following is bad:\n\ns = AutoCov(5)\nstat = Series(s, s)\n# => 10 samples but `n=20` since we've called `fit!` twice for each observation\nfit!(stat, randn(10))\n\nwhile the following is good:\n\nstat = Series(AutoCov(5), AutoCov(5))\n# => 10 samples AND `n=10`; great!\nfit!(stat, randn(10))\n\nSince at the moment the only support statistics are sub-types of OnlineStats.OnlineStat. If you want to log some custom statistic, again, at the moment, you have to make a sub-type and implement OnlineStats.fit! and OnlineStats.value. By default, a OnlineStat is passed to tensorboard by simply calling OnlineStat.value(stat). Therefore, if you also want to customize how a stat is passed to tensorbord, you need to overload TensorBoardLogger.preprocess(name, stat, data) accordingly.","category":"section"},{"location":"#Filter-variables-to-log","page":"Home","title":"Filter variables to log","text":"Maybe you want to only log stats for certain variables, e.g. in the above example we might want to exclude m and exclude the sampler statistics:\n\ncallback = TensorBoardCallback(\n    \"tensorboard_logs/run\", stats;\n    exclude = [\"m\", ], include_extras = false\n)\n\nOr you can create the filter (a mapping variable_name -> ::Bool) yourself:\n\nvar_filter(varname, value) = varname != \"m\"\ncallback = TensorBoardCallback(\n    \"tensorboard_logs/run\", stats;\n    filter = var_filter\n)","category":"section"},{"location":"#Supporting-TensorBoardCallback-with-your-own-sampler","page":"Home","title":"Supporting TensorBoardCallback with your own sampler","text":"It's also possible to make your own sampler compatible with TensorBoardCallback.\n\nTo do so, you need to implement the following method:\n\nIf you don't have any particular names for your parameters, you're free to make use of the convenience method\n\nnote: Note\nThe params_and_values(model, sampler, transition, state; kwargs...) is not usually overloaded, but it can sometimes be useful for defining more complex behaviors.\n\nFor example, if the transition for your MySampler is just a Vector{Float64}, a basic implementation of TuringCallbacks.params_and_values would just be\n\nfunction TuringCallbacks.params_and_values(transition::Vectorr{Float64}; kwargs...)\n    param_names = TuringCallbacks.default_param_names_for_values(transition)\n    return zip(param_names, transition)\nend\n\nOr sometimes the user might pass the parameter names in as a keyword argument, and so you might want to support that with something like\n\nfunction TuringCallbacks.params_and_values(transition::Vectorr{Float64}; param_names = nothing, kwargs...)\n    param_names = isnothing(param_names) ? TuringCallbacks.default_param_names_for_values(transition) : param_names\n    return zip(param_names, transition)\nend\n\nFinally, if you in addition want to log \"extra\" information, e.g. some sampler statistics you're keeping track of, you also need to implement","category":"section"},{"location":"#Types-and-Functions","page":"Home","title":"Types & Functions","text":"","category":"section"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#TuringCallbacks.params_and_values","page":"Home","title":"TuringCallbacks.params_and_values","text":"params_and_values(model, transition[, state]; kwargs...)\nparams_and_values(model, sampler, transition, state; kwargs...)\n\nReturn an iterator over parameter names and values from a transition.\n\n\n\n\n\n","category":"function"},{"location":"#TuringCallbacks.default_param_names_for_values","page":"Home","title":"TuringCallbacks.default_param_names_for_values","text":"default_param_names_for_values(x)\n\nReturn an iterator of θ[i] for each element in x.\n\n\n\n\n\n","category":"function"},{"location":"#TuringCallbacks.extras","page":"Home","title":"TuringCallbacks.extras","text":"extras(model, transition[, state]; kwargs...)\nextras(model, sampler, transition, state; kwargs...)\n\nReturn an iterator with elements of the form (name, value) for additional statistics in transition.\n\nDefault implementation returns an empty iterator.\n\n\n\n\n\n","category":"function"},{"location":"#TuringCallbacks.MultiCallback","page":"Home","title":"TuringCallbacks.MultiCallback","text":"MultiCallback\n\nA callback that combines multiple callbacks into one.\n\nImplements push!! to add callbacks to the list.\n\n\n\n\n\n","category":"type"},{"location":"#TuringCallbacks.Skip","page":"Home","title":"TuringCallbacks.Skip","text":"mutable struct Skip{T, O<:OnlineStat{T}} <: OnlineStat{T}\n\nUsage\n\nSkip(b::Int, stat::OnlineStat)\n\nSkips the first b observations before passing them on to stat.\n\n\n\n\n\n","category":"type"},{"location":"#TuringCallbacks.TensorBoardCallback","page":"Home","title":"TuringCallbacks.TensorBoardCallback","text":"struct TensorBoardCallback{L, F1, F2, F3}\n\nWraps a CoreLogging.AbstractLogger to construct a callback to be passed to AbstractMCMC.step.\n\nUsage\n\nTensorBoardCallback(; kwargs...)\nTensorBoardCallback(directory::string[, stats]; kwargs...)\nTensorBoardCallback(lg::AbstractLogger[, stats]; kwargs...)\n\nConstructs an instance of a TensorBoardCallback, creating a TBLogger if directory is provided instead of lg.\n\nArguments\n\nlg: an instance of an AbstractLogger which implements TuringCallbacks.increment_step!.\nstats = nothing: OnlineStat or lookup for variable name to statistic estimator. If stats isa OnlineStat, we will create a DefaultDict which copies stats for unseen variable names. If isnothing, then a DefaultDict with a default constructor returning a OnlineStats.Series estimator with Mean(), Variance(), and KHist(num_bins) will be used.\n\nKeyword arguments\n\nnum_bins::Int = 100: Number of bins to use in the histograms.\nfilter = nothing: Filter determining whether or not we should log stats for a particular variable and value; expected signature is filter(varname, value). If isnothing a default-filter constructed from exclude and include will be used.\nexclude = String[]: If non-empty, these variables will not be logged.\ninclude = String[]: If non-empty, only these variables will be logged.\ninclude_extras::Bool = true: Include extra statistics from transitions.\nextras_include = String[]: If non-empty, only these extra statistics will be logged.\nextras_exclude = String[]: If non-empty, these extra statistics will not be logged.\nextras_filter = nothing: Filter determining whether or not we should log  extra statistics; expected signature is filter(extra, value).  If isnothing a default-filter constructed from extras_exclude and  extras_include will be used.\ninclude_hyperparams::Bool = true: Include hyperparameters.\nhyperparam_include = String[]: If non-empty, only these hyperparameters will be logged.\nhyperparam_exclude = String[]: If non-empty, these hyperparameters will not be logged.\nhyperparam_filter = nothing: Filter determining whether or not we should log  hyperparameters; expected signature is filter(hyperparam, value).  If isnothing a default-filter constructed from hyperparam_exclude and  hyperparam_include will be used.\ndirectory::String = nothing: if specified, will together with comment be used to  define the logging directory.\ncomment::String = nothing: if specified, will together with directory be used to  define the logging directory.\n\nFields\n\nlogger::Base.CoreLogging.AbstractLogger: Underlying logger.\nstats::Any: Lookup for variable name to statistic estimate.\nvariable_filter::Any: Filter determining whether to include stats for a particular variable.\ninclude_extras::Bool: Include extra statistics from transitions.\nextras_filter::Any: Filter determining whether to include a particular extra statistic.\ninclude_hyperparams::Bool: Include hyperparameters.\nhyperparam_filter::Any: Filter determining whether to include a particular hyperparameter.\nparam_prefix::String: Prefix used for logging realizations/parameters\nextras_prefix::String: Prefix used for logging extra statistics\n\n\n\n\n\n","category":"type"},{"location":"#TuringCallbacks.Thin","page":"Home","title":"TuringCallbacks.Thin","text":"mutable struct Thin{T, O<:OnlineStat{T}} <: OnlineStat{T}\n\nUsage\n\nThin(b::Int, stat::OnlineStat)\n\nThins stat with an interval b, i.e. only passes every b-th observation to stat.\n\n\n\n\n\n","category":"type"},{"location":"#TuringCallbacks.WindowStat","page":"Home","title":"TuringCallbacks.WindowStat","text":"struct WindowStat{T, O} <: OnlineStat{T}\n\nUsage\n\nWindowStat(b::Int, stat::O) where {O <: OnlineStat}\n\n\"Wraps\" stat in a MovingWindow of length b.\n\nvalue(o::WindowStat) will then return an OnlineStat of the same type as  stat, which is only fitted on the batched data contained in the MovingWindow.\n\n\n\n\n\n","category":"type"},{"location":"#TuringCallbacks.default_param_names_for_values-Tuple{Any}","page":"Home","title":"TuringCallbacks.default_param_names_for_values","text":"default_param_names_for_values(x)\n\nReturn an iterator of θ[i] for each element in x.\n\n\n\n\n\n","category":"method"},{"location":"#TuringCallbacks.extras-Tuple{Any, Any}","page":"Home","title":"TuringCallbacks.extras","text":"extras(model, transition[, state]; kwargs...)\nextras(model, sampler, transition, state; kwargs...)\n\nReturn an iterator with elements of the form (name, value) for additional statistics in transition.\n\nDefault implementation returns an empty iterator.\n\n\n\n\n\n","category":"method"},{"location":"#TuringCallbacks.filter_extras_and_value-Tuple{TensorBoardCallback, Any, Any}","page":"Home","title":"TuringCallbacks.filter_extras_and_value","text":"filter_extras_and_value(cb::TensorBoardCallback, name, value)\n\nFilter extras and values from a transition based on the filter of cb.\n\n\n\n\n\n","category":"method"},{"location":"#TuringCallbacks.filter_hyperparams_and_value-Tuple{TensorBoardCallback, Any, Any}","page":"Home","title":"TuringCallbacks.filter_hyperparams_and_value","text":"filter_hyperparams_and_value(cb::TensorBoardCallback, name, value)\n\nFilter hyperparameters and values from a transition based on the filter of cb.\n\n\n\n\n\n","category":"method"},{"location":"#TuringCallbacks.filter_param_and_value-Tuple{TensorBoardCallback, Any, Any}","page":"Home","title":"TuringCallbacks.filter_param_and_value","text":"filter_param_and_value(cb::TensorBoardCallback, param_name, value)\n\nFilter parameters and values from a transition based on the filter of cb.\n\n\n\n\n\n","category":"method"},{"location":"#TuringCallbacks.hyperparam_metrics-Tuple{Any, Any}","page":"Home","title":"TuringCallbacks.hyperparam_metrics","text":"hyperparam_metrics(model, sampler[, transition, state]; kwargs...)\n\nReturn a Vector{String} of metrics for hyperparameters in model.\n\n\n\n\n\n","category":"method"},{"location":"#TuringCallbacks.hyperparams-Tuple{Any, Any}","page":"Home","title":"TuringCallbacks.hyperparams","text":"hyperparams(model, sampler[, transition, state]; kwargs...)\n\nReturn an iterator with elements of the form (name, value) for hyperparameters in model.\n\n\n\n\n\n","category":"method"},{"location":"#TuringCallbacks.params_and_values-Tuple{Any, Any, Any}","page":"Home","title":"TuringCallbacks.params_and_values","text":"params_and_values(model, transition[, state]; kwargs...)\nparams_and_values(model, sampler, transition, state; kwargs...)\n\nReturn an iterator over parameter names and values from a transition.\n\n\n\n\n\n","category":"method"},{"location":"#TuringCallbacks.push!!-Tuple{MultiCallback{<:Tuple}, Any}","page":"Home","title":"TuringCallbacks.push!!","text":"push!!(cb::MultiCallback, callback)\n\nAdd a callback to the list of callbacks, mutating if possible.\n\n\n\n\n\n","category":"method"},{"location":"#TuringCallbacks.tb_name-Tuple{Any}","page":"Home","title":"TuringCallbacks.tb_name","text":"tb_name(args...)\n\nReturns a string representing the name for arg or args in TensorBoard.\n\nIf length(args) > 1, args are joined together by \"/\".\n\n\n\n\n\n","category":"method"}]
}
